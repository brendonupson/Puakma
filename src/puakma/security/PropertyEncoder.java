/** ***************************************************************
PropertyEncoder.java
Copyright (C) 2001  Brendon Upson 
http://www.wnc.net.au info@wnc.net.au

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

 *************************************************************** */

package puakma.security;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import puakma.security.TripleDESCoder.EncryptionException;
import puakma.util.Util;

/**
 *
 * @author  bupson
 */
public class PropertyEncoder 
{
	private static final String PREAMBLE = "%%$%%";
	//do not change!! randomly generated bytes follow
	private String CRYPTER;// = "8A/Tl316CXblNXF1p/fLi+jnC4kBbO5G";
	private TripleDESCoder m_3descoder=null;
	puakma.coder.CoderB64 m_B64coder = new puakma.coder.CoderB64();

	/** Creates a new instance of PropertyEncoder */
	public PropertyEncoder(String sBase64SecretKey) throws EncryptionException
	{
		setSecretKey(sBase64SecretKey);
		m_3descoder = new TripleDESCoder(CRYPTER);         
	}

	/**
	 *
	 */
	public synchronized void setSecretKey(String sBase64Key)
	{
		if(sBase64Key==null || sBase64Key.length()==0)
		{
			//generate
			try
			{   
				KeyGenerator keyGen = KeyGenerator.getInstance("DESede");                 
				SecretKey key = keyGen.generateKey();               
				byte[] keyBytes = key.getEncoded();

				CRYPTER = m_B64coder.encode(keyBytes); 
				//System.out.println("CRYPTER:"+CRYPTER);
			} catch (java.security.NoSuchAlgorithmException e){} 

		}
		else
			CRYPTER = resolveKey(sBase64Key);
	}

	/**
	 *
	 */
	private String resolveKey(String sEncodedKey)
	{        
		byte[] keyFullBytes = m_B64coder.decode(sEncodedKey.getBytes());
		byte[] keyBytes = new byte[(int)(keyFullBytes.length/2)];
		int k=0;
		for(int i=0; i<keyFullBytes.length; i+=2)
		{
			keyBytes[k++] = keyFullBytes[i];
		}
		return m_B64coder.encode(keyBytes);
	}

	/*public String getCrypter()
    {
        return CRYPTER;
    }*/

	/**
	 *
	 */
	public String getSecretKey()
	{
		//generate a new key and hide the original inside
		//every second byte is a red herring
		try
		{   
			puakma.coder.CoderB64 coder = new puakma.coder.CoderB64();
			KeyGenerator keyGen = KeyGenerator.getInstance("DESede");                                              
			byte[] keyBytes = coder.decode(CRYPTER.getBytes());

			SecretKey key2 = keyGen.generateKey();
			byte[] obscuredBytes = key2.getEncoded();


			byte bufFinal[] = new byte[keyBytes.length*2];
			int k=0;
			for(int i=0; i<keyBytes.length; i++)
			{
				bufFinal[k++] = keyBytes[i];
				bufFinal[k++] = obscuredBytes[i];
			}
			return coder.encode(bufFinal);               
		} catch (java.security.NoSuchAlgorithmException e){} 
		return "";
	}

	/*public static void main(String sargs[])
    {
        try
        {
           String sOld = "%%$%%C8x0tx6MFPc=";
           String sKey = "5SPHhiZAg+/gcK0gIz1DUV1wrajvrkwNs/gTZ2io74ZegFTvIDhup5I4XdAW3KRk";
           PropertyEncoder pe = new PropertyEncoder(sKey);

           System.out.println("CRYPT_orig:5ccmg+CtI0Ndre9MsxNo715UIG6SXRak");
           System.out.println("CRYPT     :"+pe.getCrypter());
           //File f = new File("/data/test.config");
           //pe.encodeConfigFile(f);
           String sOriginal = "junk";
           String sEncoded = pe.encode(sOriginal);
           String sDecoded = pe.decode(sEncoded);
           String sDecoded2 = pe.decode(sOriginal);
           String sDecoded3 = pe.decode(sOld);

           System.out.println("-------------------");
           System.out.println("key is  ="+pe.getSecretKey());
           System.out.println("original="+sOriginal);
           System.out.println("encoded ="+sEncoded);
           System.out.println("decoded ="+sDecoded);
           System.out.println("decoded2="+sDecoded2);
           System.out.println("decoded3="+sDecoded3);

        }
        catch(Exception e)
        {
            //System.out.println(e.toString());
            e.printStackTrace();
        }
    }
	 */

	/**
	 * Used to encode a properties file
	 *
	 */
	public void encodeConfigFile(String sFilePath) throws Exception
	{
		if(sFilePath==null || sFilePath.length()==0) return;
		File f = new File(sFilePath);           
		encodeConfigFile(f);
	}

	/**
	 * Used to encode a properties file
	 *
	 */
	public void encodeConfigFile(File fProps) throws Exception
	{
		String sEncryptFields[] = new String[]{"SystemPW", "SysAdminPWSetup", 
				"HTTPSSLKeyRingPW", "HTTPSSLTrustStorePW", "BOOSTERSSLKeyRingPW", "BOOSTERSSLTrustStorePW", "CLUSTERSSLKeyRingPW", "LDAPBindPassword",
				"WEBSSOLDAPPW","WEBSSO3DESData","WEBSSORSAData","WEBSSOKerberosPrincipalPW", "MAILERSmartHostPassword"};
		if(fProps==null) return;
		if(!fProps.isFile()) return;

		ArrayList arr = loadProperties(new FileInputStream(fProps));
		//boolean bChanged = false;

		for(int i=0; i<arr.size(); i++)
		{
			String sLine = (String)arr.get(i);
			String sKeyName = getKeyName(sLine);
			if(sKeyName.endsWith("_")) //keys ending in underscore will be automatically encrypted
			{
				int iPos = sLine.indexOf('=');
				String sProperty = sLine.substring(iPos+1);
				//System.out.println(sProperty);
				if(sProperty!=null && sProperty.length()>0)
				{
					String sEncoded = encode(sProperty);                        
					arr.set(i, sKeyName + "=" + sEncoded);                        
					//bChanged = true;
				}
			}
			else //test against a list of known keys that should be encrypted
			{
				for(int k=0; k<sEncryptFields.length; k++)
				{
					String sKey = sEncryptFields[k]+"=";
					if(sLine.startsWith(sKey))
					{
						//System.out.println(sLine);
						int iPos = sLine.indexOf('=');
						String sProperty = sLine.substring(iPos+1);
						//System.out.println(sProperty);
						if(sProperty!=null && sProperty.length()>0)
						{
							String sEncoded = encode(sProperty);                        
							arr.set(i, sKey + sEncoded);                        
							//bChanged = true;
						}
					}
				}//for
			}
		}


		//write the file with new line encodings
		String sEOL = System.getProperty("line.separator");
		if(sEOL==null || sEOL.length()==0) sEOL = "\r\n";
		FileOutputStream fout = new FileOutputStream(fProps);
		for(int i=0; i<arr.size(); i++)
		{
			String sLine = (String)arr.get(i);
			//System.out.println(sLine);
			fout.write((sLine+sEOL).getBytes("ISO-8859-1"));
		}
		fout.flush();
		fout.close();   
	}

	/**
	 * When passed a config file line eg "SomeKey=xxxx" will return "SomeKey"
	 * @param sLine
	 * @return
	 */
	private String getKeyName(String sLine) 
	{
		if(sLine==null || sLine.length()==0) return "";
		if(sLine.startsWith("#")) return ""; //line is commented out
		int iPos = sLine.indexOf('=');
		if(iPos>0)
		{
			return Util.trimSpaces(sLine.substring(0, iPos));
		}		
		return "";
	}

	/**
	 * load a properties file into an array
	 */
	private ArrayList loadProperties(InputStream is) throws IOException
	{
		String SYSTEM_KEY = "SystemKey=";
		boolean bFoundKey=false;

		ArrayList arr = new ArrayList();
		BufferedReader br = new BufferedReader(new InputStreamReader(is));
		String sLine="";
		while( (sLine=br.readLine()) != null)
		{
			arr.add(sLine);
			if(sLine.startsWith(SYSTEM_KEY)) bFoundKey=true;
		}

		//added to end of file. Might be nicer to slot in somewhere near the top?
		if(!bFoundKey)
		{
			arr.add(SYSTEM_KEY+getSecretKey());
		}
		return arr;
	}

	/**
	 * decode the string passed. Strings must start with the preamble in order
	 * to be decoded, otherwise they are treated as clear text.
	 */
	public String decode(String sProperty) throws EncryptionException
	{
		if(sProperty==null) return null;
		if(!sProperty.startsWith(PREAMBLE)) return sProperty;

		String sStripped = sProperty.substring(PREAMBLE.length());
		return m_3descoder.decodeString(sStripped);
	}

	/**
	 * Encodes a property into our internal format
	 */
	public String encode(String sProperty) throws EncryptionException
	{
		if(sProperty==null || sProperty.length()==0 || sProperty.startsWith(PREAMBLE)) return sProperty;

		return PREAMBLE + m_3descoder.encodeString(sProperty);        
	}

	/**
	 * String the newlines from the base64 encoder's output. Grrrr! why does it do this??
	 */
	public static String stripNewlines(char cArray[])
	{
		StringBuilder sb = new StringBuilder(cArray.length);
		for(int i=0; i<cArray.length; i++)
		{
			if(!(cArray[i]=='\r' || cArray[i]=='\n'))
				sb.append(cArray[i]);            
		}
		return sb.toString();
	}

}//class
